
======================================================================================

Contenu du fichier : public\camera\camera.js

======================================================================================
import * as THREE from "https://esm.sh/three@0.160";

export function updateCamera(cube) {
  if (!cube) return;

  const offset = new THREE.Vector3(0, 0.5, 0); // position de la caméra sur le cube (légèrement en hauteur)
  const cubePos = cube.position.clone().add(offset);

  myCamera.position.copy(cubePos);
  myCamera.lookAt(cubePos.x, cubePos.y, cubePos.z -1); // regarde droit devant
}

export const myCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);0
======================================================================================

Contenu du fichier : public\constant.js

======================================================================================
// constant pour changer l'url

export const port = 3000; // port du serveur
export const local = "http://localhost:3000/";
export const server = "http://flag.techtwins.fr/";

export const speed = 4; // vitesse de déplacement des joueurs
export const taille_map = 10; // taille de la map
export const pesanteur = -250; // force de gravité

0
======================================================================================

Contenu du fichier : public\index.html

======================================================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>FlagRush</title>
    <style>
      body {
        margin: 0;
      }
    </style>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <script type="module" src="./main.js"></script>
  </body>
</html>
0
======================================================================================

Contenu du fichier : public\lightings\light.js

======================================================================================
import * as THREE from "https://esm.sh/three@0.160";

export const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 10, 5);
light.castShadow = true;

// Optional: fine-tune shadow quality
light.shadow.mapSize.width = 1024;
light.shadow.mapSize.height = 1024;
light.shadow.camera.near = 0.5;
light.shadow.camera.far = 50;
light.shadow.camera.left = -10;
light.shadow.camera.right = 10;
light.shadow.camera.top = 10;
light.shadow.camera.bottom = -10;

// Ambient light (soft fill light)
export const ambient = new THREE.AmbientLight(0xffffff, 0.3);
0
======================================================================================

Contenu du fichier : public\main.js

======================================================================================
import * as THREE from "https://esm.sh/three@0.160";
import RAPIER from 'https://cdn.skypack.dev/@dimforge/rapier3d-compat';
import { speed , taille_map , local , server, pesanteur} from "./constant.js";
import { updateCamera , myCamera } from "./camera/camera.js"
import { light , ambient } from "./lightings/light.js";


const socket = io(local); // a changer en server pour héberger le jeu


let myPlayer = null;
let myCube = null;
let myBody = null;
let isJumping;


let world;
await RAPIER.init();
const gravity = { x: 0, y: pesanteur, z: 0 };
world = new RAPIER.World(gravity);


const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // bleu ciel

// Création du moteur de rendu
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);


const playerBodies = {   // ici que seront les corps physiques des joueurs
  player1: null,
  player2: null,
};

// player1
const player1Desc = RAPIER.RigidBodyDesc.dynamic().setTranslation(0, 5, 0);
playerBodies.player1 = world.createRigidBody(player1Desc);
world.createCollider(RAPIER.ColliderDesc.cuboid(0.25, 0.5, 0.25), playerBodies.player1);

// player2
const player2Desc = RAPIER.RigidBodyDesc.dynamic().setTranslation(1, 5, 0);  
playerBodies.player2 = world.createRigidBody(player2Desc);  
world.createCollider(RAPIER.ColliderDesc.cuboid(0.25, 0.5, 0.25), playerBodies.player2)

world.step();

// Cube vert et rouge
const geometry = new THREE.BoxGeometry(0.5 , 1, 0.5);  // diemension des cubes joueurs

const materialGreen = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const materialRed = new THREE.MeshBasicMaterial({ color: 0xff0000  });

const greenCube = new THREE.Mesh(geometry, materialGreen);
const redCube = new THREE.Mesh(geometry, materialRed);


// visual ground
const groundGeometry = new THREE.BoxGeometry(taille_map*2, 0.2, taille_map*2); 
const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);

groundMesh.position.set(0, -0.1, 0); 

// physical ground
const groundDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, 0, 0);
const groundBody = world.createRigidBody(groundDesc);
const groundCollider = RAPIER.ColliderDesc.cuboid(taille_map, 0.1, taille_map);
world.createCollider(groundCollider, groundBody);

scene.add(greenCube);
scene.add(redCube);
scene.add(groundMesh);
scene.add(light);
scene.add(ambient);

//shadow casting

greenCube.castShadow = true;
redCube.castShadow = true;

groundMesh.receiveShadow = true;


socket.on("player-assigned", (player) => {
  myPlayer = player;
  myCube = myPlayer === "player1" ? greenCube : redCube;   // cube vert si j1 sinon cube rouge
  myBody = playerBodies[myPlayer];
});

greenCube.position.set(0, 0.44, 0)
redCube.position.set(1, 0.44, 0)

socket.on("update-positions", (positions) => {
  const otherPlayer = myPlayer === 'player1' ? 'player2' : 'player1';

  if (positions.Player1Position && playerBodies.player1 && myPlayer !== 'player1') {
    playerBodies.player1.setTranslation(positions.Player1Position, true);
  }
  if (positions.Player2Position && playerBodies.player2 && myPlayer !== 'player2') {
    playerBodies.player2.setTranslation(positions.Player2Position, true);
  }

  // sync visual positions
  greenCube.position.set(
    playerBodies.player1.translation().x,
    playerBodies.player1.translation().y,
    playerBodies.player1.translation().z
  );

  redCube.position.set(
    playerBodies.player2.translation().x,
    playerBodies.player2.translation().y,
    playerBodies.player2.translation().z
  );
});


function sendMyPosition() {
  if (!myPlayer || !myBody) return;
  const pos = myBody.translation();
  socket.emit("move-cube", {
    x: pos.x,
    y: pos.y,
    z: pos.z,
  });
}


const keys = {
  KeyW: false,
  KeyS: false,
  KeyA: false,
  KeyD: false,
  Space: false,
  ShiftLeft: false,
};

document.addEventListener("keydown", (e) => {
  if (e.code in keys) {
    keys[e.code] = true;
  }
});

document.addEventListener("keyup", (e) => {
  if (e.code in keys) {
    keys[e.code] = false;
  }
});


function updateJump(){
  if (myBody) {
    const vel = myBody.linvel();
    if (Math.abs(vel.y) < 0.01) {
      isJumping = false;
    }
  }
}

function animate() {
  requestAnimationFrame(animate);
  updateJump();

  const movement = { x: 0, y: 0, z: 0 };
  if (keys.KeyW) movement.z -= speed;
  if (keys.KeyS) movement.z += speed;
  if (keys.KeyA) movement.x -= speed;
  if (keys.KeyD) movement.x += speed;

  if (myBody) myBody.setLinvel(movement, true);

  

  if (keys.Space && isJumping === false) {
    const vel = myBody.linvel();
    if (Math.abs(vel.y) < 0.01) {
      isJumping = true;
      myBody.applyImpulse({ x: 0, y: 5, z: 0 }, true);
    }
  }

  world.step();

  // update mesh positions
  greenCube.position.copy(playerBodies.player1.translation());
  redCube.position.copy(playerBodies.player2.translation());

  sendMyPosition();
  updateCamera(myCube);
  renderer.render(scene, myCamera);
}


animate();
0
======================================================================================

Contenu du fichier : public\map\map.js

======================================================================================
0
======================================================================================

Contenu du fichier : public\style.css

======================================================================================
body {
  margin: 0;
  overflow: hidden;
}

.inner::-webkit-scrollbar {
  display: none;
}

canvas {
  display: block;
  width: 100vw;
  height: 100vh;
}
0
======================================================================================

Contenu du fichier : server.js

======================================================================================
import express from 'express';
import {Server} from 'socket.io';
import {createServer} from 'http';
import {port, local} from './public/constant.js'; // importation des constantes

const app = express();
const server = createServer(app);

const io = new Server(server, {
    cors: {
      origin: "*",
      methods: ["GET", "POST"]
    }
  });
  
  app.use(express.static("public"));

app.use(express.static("public"));

let players = {}; // socket.id -> player number
let cubePositions = {
    Player1Position: { x: 0, y: 1, z: 0 },
    Player2Position: { x: 2, y: 1, z: 0 },
};

io.on('connection', (socket) => {

    const connectedCount = Object.keys(players).length;
    if (connectedCount > 2) {                                             //limite le nombre de joueurs à 2
        console.log("Server full, disconnecting user", socket.id);
        socket.emit("error", "Game is full"); // envoie un message d'erreur au client
        socket.disconnect(true);
    }
    const playerNumber = connectedCount === 0 ? 'player1' : 'player2';  // si personne n'est co alors : playerNumber = player1 sinon player2
    players[socket.id] = playerNumber; // associe le socket.id au numéro du joueur

    console.log(`Player ${playerNumber} connected:`);
     
    socket.emit("player-assigned", playerNumber);
    io.emit("update-positions", cubePositions);  // donne la position initiale des cubes aux clients connectés


    socket.on("move-cube", (position) => {
        const player = players[socket.id]; // Met à jour la position du cube du joueur
        if (!player) return;

        const key = player === "player1" ? "Player1Position" : "Player2Position";
        cubePositions[key] = position;
        io.emit("update-positions", cubePositions); // broadcast new positions
    });


    socket.on("disconnect", () => {
        const player = players[socket.id];
        delete players[socket.id];
        console.log(`Player ${player} disconnected:`, socket.id);
      });
});


server.listen(port, () => {
    console.log(`Server running on ${local}`);

});

0